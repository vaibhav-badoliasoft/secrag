[
  {
    "chunk_id": 0,
    "content": "Network & Web Security Study Notes\nFebruary 01, 2026\nPage 1\n Network & Web Security Study Notes\nCompiled from your notes (Q&A; + simple examples).\nName: Vaibhav Saini\nCore Web & Crypto Concepts\n1. What is a three-way handshake?\nThe TCP three-way handshake establishes a connection between client and server. In other words, a\nthree-way handshake is how two computers start talking on the internet.\nSYN: Client sends SYN packet with random sequence number.\nSYN-ACK: Server responds with SYN-ACK, ackno"
  },
  {
    "chunk_id": 1,
    "content": "N: Client sends SYN packet with random sequence number.\nSYN-ACK: Server responds with SYN-ACK, acknowledging the client's sequence number and sending its\nown.\nACK: Client acknowledges the server's sequence number.\nThis ensures both parties are ready to communicate and agree on initial sequence numbers for reliable\ndata transmission.\nExample:\nStep 1. You say hello. Your computer sends a message that means, \"I want to talk.\"\nStep 2. The other computer replies. It says, \"I heard you and I am ready."
  },
  {
    "chunk_id": 2,
    "content": "t means, \"I want to talk.\"\nStep 2. The other computer replies. It says, \"I heard you and I am ready.\"\nStep 3. You confirm. You say, \"Great, let us start.\"\nAfter these three steps, both computers agree the connection is real and ready. Then they start sending\ndata, like web pages or messages.\nThis happens in TCP, the main system that moves data on the internet.\n2. How do cookies work?\nCookies are small data pieces stored on the client by the server via the Set-Cookie HTTP header. The\nbrowser auto"
  },
  {
    "chunk_id": 3,
    "content": "mall data pieces stored on the client by the server via the Set-Cookie HTTP header. The\nbrowser automatically sends cookies back to the server with subsequent requests to the same domain.\nThey're used for session management, personalization, and tracking. Security attributes include HttpOnly\n(prevents JavaScript access), Secure (HTTPS only), and SameSite (CSRF protection).\nExample:\n1. First visit (getting your \"stamp\"):\n- You visit Amazon.com and log in.\n- Amazon says: \"Cool, you're logged in! H"
  },
  {
    "chunk_id": 4,
    "content": "(getting your \"stamp\"):\n- You visit Amazon.com and log in.\n- Amazon says: \"Cool, you're logged in! Here's a special cookie to remember you.\"\n- Your browser saves this cookie.\n2. Coming back (showing your \"stamp\"):\n- You come back later.\n- Your browser automatically sends Amazon the cookie.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 2\n- Amazon reads it and says: \"Oh, it's you again! You're still logged in.\"\nWhat's actually in a cookie?\nIt's a small piece of text that might say:\n- \""
  },
  {
    "chunk_id": 5,
    "content": "You're still logged in.\"\nWhat's actually in a cookie?\nIt's a small piece of text that might say:\n- \"This is user #12345\"\n- \"They last visited on January 11\"\n- \"They have 3 items in their shopping cart\"\nWhy websites use cookies:\n- Remember you're logged in\n- Shopping carts\n- Preferences (like dark mode)\n3. How do sessions work?\nSessions maintain state across HTTP requests. The server creates a unique session ID upon user login,\nstores session data server-side, and sends the session ID to the clie"
  },
  {
    "chunk_id": 6,
    "content": "ue session ID upon user login,\nstores session data server-side, and sends the session ID to the client (typically via a cookie). On\nsubsequent requests, the client sends the session ID, allowing the server to retrieve associated session\ndata. Sessions expire after timeout or logout.\n4. Explain how OAuth works.\nOAuth 2.0 is an authorization framework allowing third-party applications limited access to user resources\nwithout exposing credentials:\n- User initiates login with third-party app\n- App r"
  },
  {
    "chunk_id": 7,
    "content": " to user resources\nwithout exposing credentials:\n- User initiates login with third-party app\n- App redirects to authorization server\n- User authenticates and grants permissions\n- Authorization server issues authorization code\n- App exchanges code for access token\n- App uses access token to access protected resources\nExample:\nYou want to let Spotify see your Facebook friends. Instead of giving Spotify your Facebook password, you\ntell Facebook: \"Let Spotify see my friends list, but nothing else.\" "
  },
  {
    "chunk_id": 8,
    "content": "ify your Facebook password, you\ntell Facebook: \"Let Spotify see my friends list, but nothing else.\" Facebook gives Spotify a special\npermission slip (token). Spotify can see your friends, but can't post as you or change your password.\n5. Explain how JWT works.\nJSON Web Tokens (JWT) are compact, self-contained tokens for secure information transmission.\nStructure: Header.Payload.Signature\n- Header: algorithm and token type\n- Payload: claims (user data, expiration)\n- Signature: HMAC or RSA signatu"
  },
  {
    "chunk_id": 9,
    "content": " algorithm and token type\n- Payload: claims (user data, expiration)\n- Signature: HMAC or RSA signature verifying integrity\nJWTs are stateless: the server doesn't store session data. The signature ensures tokens haven't been\ntampered with. Commonly used for API authentication and single sign-on.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 3\nExample:\nLike a movie ticket that has your name, the movie, the time, and a special hologram that can't be faked.\nJWT contains info about you pl"
  },
  {
    "chunk_id": 10,
    "content": "ame, the movie, the time, and a special hologram that can't be faked.\nJWT contains info about you plus a signature that proves it's real.\n6. What is a public key infrastructure flow?\nPKI manages digital certificates and public-key encryption.\nCertificate Authority (CA) issues a certificate:\n- Certificate contains the entity's public key and identity info\n- CA signs it\nVerification process:\n1. Entity presents certificate\n2. Verifier checks CA signature\n3. Validates certificate status (CRL/OCSP)\n4"
  },
  {
    "chunk_id": 11,
    "content": "ty presents certificate\n2. Verifier checks CA signature\n3. Validates certificate status (CRL/OCSP)\n4. Confirms identity and validity period\nAnalogical example:\nLike a school ID card with the principal's signature: people trust it because the principal signed it.\n7. Difference between symmetric and asymmetric encryption.\nSymmetric: same key for encryption and decryption. Fast and efficient for large data (AES, DES, 3DES).\nMain challenge is secure key distribution.\nAsymmetric: uses a public-privat"
  },
  {
    "chunk_id": 12,
    "content": "e data (AES, DES, 3DES).\nMain challenge is secure key distribution.\nAsymmetric: uses a public-private key pair. Public key encrypts, private key decrypts. Slower but solves\nkey distribution (RSA, ECC). Used for key exchange and digital signatures.\nHybrid approach: use asymmetric to exchange a symmetric key, then use symmetric for bulk data.\nSimple examples:\n- Symmetric = one house key locks and unlocks.\n- Asymmetric = mailbox: anyone can drop mail in (public key), only you can open it (private k"
  },
  {
    "chunk_id": 13,
    "content": "locks.\n- Asymmetric = mailbox: anyone can drop mail in (public key), only you can open it (private key).\n8. Describe SSL/TLS handshake.\nSSL/TLS handshake establishes a secure connection:\n- ClientHello: supported cipher suites, TLS version\n- ServerHello: selected cipher, certificate\n- Certificate verification: client validates server certificate\n- Key exchange: client and server establish shared secrets\n- Session keys generated\n- Finished messages: both verify handshake\nExample:\nTwo kids agree on"
  },
  {
    "chunk_id": 14,
    "content": "crets\n- Session keys generated\n- Finished messages: both verify handshake\nExample:\nTwo kids agree on a secret way to talk, verify it, then use a shared secret code for the conversation.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 4\n9. How does HMAC work?\nHMAC (Hash-based Message Authentication Code) provides message integrity and authenticity.\nHMAC(K, m) = H((K' XOR opad) || H((K' XOR ipad) || m))\nWhere:\n- K is secret key\n- m is message\n- H is hash function\n- opad/ipad are padding "
  },
  {
    "chunk_id": 15,
    "content": "R ipad) || m))\nWhere:\n- K is secret key\n- m is message\n- H is hash function\n- opad/ipad are padding constants\nIt combines a secret key with the message before hashing, preventing length extension attacks that can\naffect simple hash(key || message) constructions.\n10. Why HMAC is designed that way?\nHMAC's design addresses security concerns:\n- Nested hashing helps prevent length extension attacks\n- Key padding ensures the key influences the whole hash process\n- Two-pass construction (inner and oute"
  },
  {
    "chunk_id": 16,
    "content": "ey padding ensures the key influences the whole hash process\n- Two-pass construction (inner and outer hash) adds safety\n- Separates key and message to resist certain cryptanalytic attacks\nExample:\nLike a special double-seal technique that is hard to fake or move without breaking.\n11. Authentication vs authorization?\nAuthentication = \"Who are you?\" (verifying identity).\nAuthorization = \"What can you do?\" (permissions after identity is known).\nExample:\nYou log into Netflix (authentication). Your p"
  },
  {
    "chunk_id": 17,
    "content": "u do?\" (permissions after identity is known).\nExample:\nYou log into Netflix (authentication). Your profile can only watch kids shows (authorization).\n12. Diffie-Hellman vs RSA?\nDiffie-Hellman: key exchange protocol. Two parties establish a shared secret over an insecure channel\nwithout sending the secret itself. Often provides forward secrecy (with ephemeral DH).\nRSA: asymmetric encryption and digital signatures. Can encrypt data and sign messages. Does not\nautomatically provide forward secrecy "
  },
  {
    "chunk_id": 18,
    "content": "ital signatures. Can encrypt data and sign messages. Does not\nautomatically provide forward secrecy unless used in a way that supports it.\nDH is mainly for key agreement; RSA is for encryption and signatures.\n13. How does Kerberos work?\nKerberos is a network authentication protocol using tickets:\n- AS request: client requests Ticket Granting Ticket (TGT)\n- AS response: receives TGT encrypted with user's password hash\n- TGS request: client presents TGT, requests service ticket\n- TGS response: rec"
  },
  {
    "chunk_id": 19,
    "content": "user's password hash\n- TGS request: client presents TGT, requests service ticket\n- TGS response: receives service ticket\n- AP request: presents service ticket to application server\n- Access granted: server validates ticket\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 5\nUses symmetric encryption, time-based tickets, and mutual authentication. Common in Active Directory.\n14. Compress vs encrypt - which first and why?\nCompress first, then encrypt.\n- Compression finds patterns; encrypti"
  },
  {
    "chunk_id": 20,
    "content": " encrypt - which first and why?\nCompress first, then encrypt.\n- Compression finds patterns; encryption removes patterns\n- Encrypted data looks random and doesn't compress well\n- Compressing encrypted data wastes resources\nExample:\nFold clothes first (compress), then lock the suitcase (encrypt).\n15. How do I authenticate you and know you sent the message?\nUse digital signatures:\n- Sender hashes the message\n- Encrypts the hash with their private key (signature)\n- Sends message + signature\n- Receiv"
  },
  {
    "chunk_id": 21,
    "content": " message\n- Encrypts the hash with their private key (signature)\n- Sends message + signature\n- Receiver decrypts signature with sender's public key\n- Receiver hashes the received message and compares\nIf they match, the message is authentic and unmodified. You also need a verified public key (via\nPKI/certificates).\n16. Should you encrypt all data at rest?\nNot necessarily all data. Encrypt when:\n- PII, financial data, health records\n- passwords, API keys, secrets\n- regulated or sensitive business d"
  },
  {
    "chunk_id": 22,
    "content": "I, financial data, health records\n- passwords, API keys, secrets\n- regulated or sensitive business data\nYou may skip for:\n- public information\n- non-sensitive logs\n- cases where performance/cost outweighs risk (still evaluate carefully)\nBalance security needs with performance impact, key management, and compliance.\n17. What is Perfect Forward Secrecy (PFS)?\nPFS ensures past session keys stay safe even if the server's private key is compromised later. Achieved\nusing ephemeral key exchange (DHE/EC"
  },
  {
    "chunk_id": 23,
    "content": "even if the server's private key is compromised later. Achieved\nusing ephemeral key exchange (DHE/ECDHE). Each session uses a unique key that isn't stored, so\nrecorded traffic can't be decrypted later with a stolen long-term key.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 6\nNetwork Level and Logging\nCommon ports involving security: risks and mitigations\nCommon ports:\n- 20/21 (FTP): unencrypted; use SFTP/FTPS\n- 22 (SSH): brute force; use keys, rate limiting, fail2ban\n- 23 (Telnet):"
  },
  {
    "chunk_id": 24,
    "content": "unencrypted; use SFTP/FTPS\n- 22 (SSH): brute force; use keys, rate limiting, fail2ban\n- 23 (Telnet): unencrypted; replace with SSH\n- 25 (SMTP): spam relay; require auth, use 587 for submission\n- 53 (DNS): tunneling, amplification; use DNSSEC, rate limiting\n- 80 (HTTP): unencrypted; redirect to HTTPS\n- 443 (HTTPS): still app attacks; use WAF, proper TLS config\n- 3306 (MySQL): exposed DB; bind to localhost/private, firewall\n- 3389 (RDP): brute force; use VPN, strong passwords, NLA\n- 8080/8443 (alt"
  },
  {
    "chunk_id": 25,
    "content": "calhost/private, firewall\n- 3389 (RDP): brute force; use VPN, strong passwords, NLA\n- 8080/8443 (alt HTTP/HTTPS): often forgotten; monitor like 80/443\nDNS port:\nPort 53 for DNS, using both UDP (queries) and TCP (zone transfers, large responses).\nDescribe HTTPS and how it is used.\nHTTPS is HTTP over TLS/SSL and provides:\n- Encryption (confidentiality)\n- Authentication (server identity via certificates)\n- Integrity (prevents tampering)\nUsed to protect credentials, financial transactions, and sensi"
  },
  {
    "chunk_id": 26,
    "content": "tes)\n- Integrity (prevents tampering)\nUsed to protect credentials, financial transactions, and sensitive data in transit.\nDifference between HTTPS and SSL.\nHTTPS is a protocol (HTTP over TLS/SSL).\nSSL is an old/deprecated encryption protocol. Modern HTTPS uses TLS (TLS 1.2 and TLS 1.3). People\nstill say \"SSL\" but usually mean TLS.\nHow does threat modeling work?\nThreat modeling is a systematic way to identify and reduce risk:\n1. Identify assets\n2. Identify threats (e.g., STRIDE: Spoofing, Tamperi"
  },
  {
    "chunk_id": 27,
    "content": "to identify and reduce risk:\n1. Identify assets\n2. Identify threats (e.g., STRIDE: Spoofing, Tampering, Repudiation, Information Disclosure, DoS,\nElevation of Privilege)\n3. Identify vulnerabilities\n4. Assess risk (likelihood x impact)\n5. Define mitigations\n6. Validate and repeat (iterative)\nFrameworks: STRIDE, PASTA, DREAD, Attack Trees.\nWhat is a subnet and how is it useful in security?\nA subnet is a logical subdivision of an IP network. Security benefits:\n- Segmentation (isolate sensitive syst"
  },
  {
    "chunk_id": 28,
    "content": "is a logical subdivision of an IP network. Security benefits:\n- Segmentation (isolate sensitive systems)\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 7\n- Smaller blast radius\n- Access control between subnets (firewalls, ACLs)\n- Easier monitoring\n- Compliance separation (DMZ vs app vs DB vs management).\nWhat is a subnet mask?\nA subnet mask determines which part of an IP address is the network and which part is the host.\nExample: 192.168.1.0/24 with mask 255.255.255.0.\nNetwork: 192.16"
  },
  {
    "chunk_id": 29,
    "content": "network and which part is the host.\nExample: 192.168.1.0/24 with mask 255.255.255.0.\nNetwork: 192.168.1\nHosts: 1-254 usable.\nExplain what traceroute is.\nTraceroute maps the path packets take using TTL (Time To Live). It sends packets with increasing TTL:\n- TTL=1 expires at first router (ICMP Time Exceeded)\n- TTL=2 expires at second router\n- continues until destination reached\nShows each hop and latency. Useful for diagnosing routing issues.\nExplain TCP/IP concepts.\nTCP/IP is the protocol suite f"
  },
  {
    "chunk_id": 30,
    "content": "tency. Useful for diagnosing routing issues.\nExplain TCP/IP concepts.\nTCP/IP is the protocol suite for internet communication:\n- IP: addressing and routing packets\n- TCP: reliable, ordered, error-checked delivery\n- UDP: connectionless, faster, no guarantees\n- ICMP: errors and diagnostics\nCommon 4 layers: Network Access, Internet, Transport, Application.\nWhat is OSI model?\nSeven layers:\n1. Physical\n2. Data Link\n3. Network\n4. Transport\n5. Session\n6. Presentation\n7. Application\nMnemonic: Please Do "
  },
  {
    "chunk_id": 31,
    "content": "\n2. Data Link\n3. Network\n4. Transport\n5. Session\n6. Presentation\n7. Application\nMnemonic: Please Do Not Throw Sausage Pizza Away.\nRouter vs switch?\nRouter (Layer 3): routes between networks using IP, uses routing tables, connects LANs to WANs, often\ndoes NAT/firewalling.\nSwitch (Layer 2): connects devices within a network using MAC addresses, forwards frames based on\nMAC table, fast local traffic.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 8\nTCP vs UDP - which is more secure and w"
  },
  {
    "chunk_id": 32,
    "content": "\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 8\nTCP vs UDP - which is more secure and why?\nNeither is inherently \"more secure.\" Security depends on what runs on top (TLS, app auth, etc.).\nTCP has connection tracking which can reduce some spoofing. UDP is easier to spoof, but can still be\nsecured (e.g., DTLS, app-layer checks).\nIPsec Phase 1 vs Phase 2?\nPhase 1 (IKE SA): builds a secure authenticated channel to negotiate.\n- chooses crypto algorithms\n- authenticates peers\n- establishe"
  },
  {
    "chunk_id": 33,
    "content": "e authenticated channel to negotiate.\n- chooses crypto algorithms\n- authenticates peers\n- establishes IKE Security Association\nPhase 2 (IPsec SA): negotiates the actual tunnel parameters and protected traffic.\nPhase 1 protects Phase 2 negotiation; Phase 2 protects data.\nBiggest AWS security vulnerabilities?\nCommon issues:\n- Misconfigured S3 buckets (public access)\n- Overly permissive IAM policies\n- Exposed access keys (in repos)\n- Missing encryption at rest/in transit\n- Open security groups (0.0"
  },
  {
    "chunk_id": 34,
    "content": "- Exposed access keys (in repos)\n- Missing encryption at rest/in transit\n- Open security groups (0.0.0.0/0)\n- No MFA\n- No logging/monitoring (CloudTrail/GuardDuty off)\n- Unpatched instances\n- Public snapshots (EBS/RDS)\n- Shared responsibility misunderstandings\nHow do web certificates for HTTPS work?\nCertificates (X.509) prove server identity:\n- CA issues cert after verification\n- Cert includes domain, public key, validity, CA signature\n- Browser checks trust chain, expiry, domain match, revocati"
  },
  {
    "chunk_id": 35,
    "content": "ain, public key, validity, CA signature\n- Browser checks trust chain, expiry, domain match, revocation (CRL/OCSP)\n- Prevents MITM by verifying identity before encryption.\nPurpose of TLS?\nTLS provides:\n- Confidentiality (encryption)\n- Integrity (MAC)\n- Authentication (certificates, optionally client certs)\nUsed for HTTPS, email, VPNs, and more.\nIs ARP UDP or TCP?\nNeither. ARP is Layer 2 (Data Link) and maps IP addresses to MAC addresses on the local network.\nWhat information is added at each OSI "
  },
  {
    "chunk_id": 36,
    "content": " and maps IP addresses to MAC addresses on the local network.\nWhat information is added at each OSI layer?\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 9\nEncapsulation example:\n- L7 Application: app data (HTTP request)\n- L6 Presentation: encoding/encryption/compression metadata\n- L5 Session: session identifiers\n- L4 Transport: ports, sequence numbers, checksums (TCP/UDP headers)\n- L3 Network: IP addresses, TTL, protocol (IP header)\n- L2 Data Link: MAC addresses, frame check sequence"
  },
  {
    "chunk_id": 37,
    "content": "Network: IP addresses, TTL, protocol (IP header)\n- L2 Data Link: MAC addresses, frame check sequence (Ethernet header/trailer)\n- L1 Physical: bits/signals on the wire\nWhat is a firewall? How does it work? In cloud?\nA firewall controls traffic based on rules.\n- Packet filtering: checks IP/port/protocol\n- Stateful inspection: tracks connections\n- App-layer firewalls: deep inspection\nCloud examples:\n- AWS Security Groups (stateful, instance-level)\n- Network ACLs (stateless, subnet-level)\n- WAF (app"
  },
  {
    "chunk_id": 38,
    "content": "- AWS Security Groups (stateful, instance-level)\n- Network ACLs (stateless, subnet-level)\n- WAF (app-layer, OWASP Top 10 protection)\n- Virtual appliances (traditional firewalls as VMs)\nDifference between IDS and IPS?\nIDS: detects and alerts; does not block (out-of-band).\nIPS: inline; can block/drop traffic; risk of false positives blocking legit traffic.\nHow do you harden a system?\nCommon hardening steps:\n- remove unnecessary services/apps\n- patch regularly\n- strong authentication (MFA, SSH keys"
  },
  {
    "chunk_id": 39,
    "content": "g steps:\n- remove unnecessary services/apps\n- patch regularly\n- strong authentication (MFA, SSH keys)\n- least privilege\n- firewall rules\n- remove/disable default accounts\n- audit logging\n- encryption\n- follow baselines (CIS, STIG)\n- vulnerability scanning and monitoring\n- network segmentation\nWhat would you do if you discovered an infected host?\nIncident response:\n- contain/isolate host\n- identify scope and malware type\n- preserve evidence (memory/disk images)\n- eradicate (remove malware / rebui"
  },
  {
    "chunk_id": 40,
    "content": " scope and malware type\n- preserve evidence (memory/disk images)\n- eradicate (remove malware / rebuild)\n- recover from clean backup\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 10\n- monitor for reinfection\n- document and do lessons learned\nApproach to memory dump analysis?\nMemory forensics steps:\n- confirm OS/profile\n- list processes and suspicious parent/child\n- network connections and listening ports\n- check injection/hollowing/DLLs\n- persistence artifacts\n- extract/dump suspiciou"
  },
  {
    "chunk_id": 41,
    "content": "nd listening ports\n- check injection/hollowing/DLLs\n- persistence artifacts\n- extract/dump suspicious processes\n- correlate with disk/logs\nTools: Volatility, Rekall, Redline, YARA rules\nHow would you detect a DDoS attack?\nIndicators:\n- sudden traffic spike\n- geographic anomalies\n- high latency/timeouts\n- resource exhaustion (CPU/memory/bandwidth)\n- many failed connections (SYN floods)\n- repeated patterns (same user agents/requests)\nUse baselines + monitoring tools (NetFlow/sFlow, WAF/CDN alerts,"
  },
  {
    "chunk_id": 42,
    "content": "atterns (same user agents/requests)\nUse baselines + monitoring tools (NetFlow/sFlow, WAF/CDN alerts, SIEM).\nHow does the kernel know which function to call for the user?\nThrough system calls:\n- program invokes a syscall (via libc wrapper)\n- syscall number placed in a register\n- CPU switches to kernel mode via syscall instruction/interrupt\n- kernel uses syscall table to map number to function pointer\n- executes and returns to user mode with result\nReverse-engineering a custom protocol packet?\nApp"
  },
  {
    "chunk_id": 43,
    "content": "er\n- executes and returns to user mode with result\nReverse-engineering a custom protocol packet?\nApproach:\n- capture traffic (Wireshark/tcpdump)\n- find fixed vs variable fields, magic bytes, length fields\n- compare multiple samples\n- guess header/payload structure, checksums\n- test hypotheses by modifying packets and observing responses\n- detect encryption via high entropy\n- document protocol flow/state machine\nTools: Wireshark, scapy, 010 Editor\nDifferentiate XSS from CSRF.\nNetwork & Web Securi"
  },
  {
    "chunk_id": 44,
    "content": "/state machine\nTools: Wireshark, scapy, 010 Editor\nDifferentiate XSS from CSRF.\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 11\nXSS: injects malicious script into a page; runs in victim browser; can steal cookies/session tokens.\nMitigate with output encoding, input validation, CSP.\nCSRF: tricks an authenticated user into making unwanted state-changing requests. Mitigate with CSRF\ntokens, SameSite cookies, Origin/Referer checks.\nWhat is SSRF?\nServer-Side Request Forgery: attacker mak"
  },
  {
    "chunk_id": 45,
    "content": "ns, SameSite cookies, Origin/Referer checks.\nWhat is SSRF?\nServer-Side Request Forgery: attacker makes the server send requests to unintended locations (internal\nservices, cloud metadata like 169.254.169.254, etc.).\nMitigation: allowlist URLs, block private IP ranges, disable risky protocols, validate/sanitize URLs,\nsegment networks.\nPadlock icon in browser - how is it generated?\nBrowser shows the lock when:\n- TLS handshake succeeds\n- certificate validates (trusted CA chain, not expired, domain "
  },
  {
    "chunk_id": 46,
    "content": " lock when:\n- TLS handshake succeeds\n- certificate validates (trusted CA chain, not expired, domain match, not revoked)\n- page is loaded without blocked mixed content (or appropriate secure indicators)\nWhat is Same Origin Policy and CORS?\nSOP: browser rule that scripts from one origin cannot access data from another origin.\nOrigin = scheme + domain + port.\nCORS: server-controlled way to relax SOP using headers like:\n- Access-Control-Allow-Origin\n- Access-Control-Allow-Methods\n- Access-Control-Al"
  },
  {
    "chunk_id": 47,
    "content": "using headers like:\n- Access-Control-Allow-Origin\n- Access-Control-Allow-Methods\n- Access-Control-Allow-Headers\nPreflight OPTIONS used for complex requests.\nSecure a MongoDB database?\nKey steps:\n- enable authentication and RBAC\n- use TLS for connections\n- encrypt at rest\n- bind to localhost/private interfaces; firewall\n- patch regularly\n- enable audit logs\n- backups (encrypted, tested restores)\n- disable unused features (like server-side JS if not needed)\nSecure PostgreSQL?\nKey steps:\n- use scra"
  },
  {
    "chunk_id": 48,
    "content": "disable unused features (like server-side JS if not needed)\nSecure PostgreSQL?\nKey steps:\n- use scram-sha-256 (or md5) rather than trust\n- strict pg_hba.conf rules\n- least privilege roles, avoid superuser\n- require TLS\n- listen only where needed + firewall\nNetwork & Web Security Study Notes\nFebruary 01, 2026\nPage 12\n- patch regularly\n- audit logging (pgaudit)\n- optional row-level security\n- encrypted backups, test restore\nDB exfiltrated: SHA256 (single round) with static salt - what now?\nRisk: h"
  },
  {
    "chunk_id": 49,
    "content": "ted backups, test restore\nDB exfiltrated: SHA256 (single round) with static salt - what now?\nRisk: high. Single-round SHA256 is fast to crack, and a static salt is weak.\nImmediate actions:\n- force password reset for affected users\n- monitor for credential stuffing\n- investigate and close the breach vector, review logs\nChanges:\n- move to bcrypt/scrypt/Argon2 with per-user random salts\n- use key stretching (iterations)\n- consider adding a pepper (app-level secret)\n- implement MFA and improve detec"
  },
  {
    "chunk_id": 50,
    "content": "etching (iterations)\n- consider adding a pepper (app-level secret)\n- implement MFA and improve detection/response\n"
  }
]